# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities

__all__ = [
    'BoardQueryArgs',
    'BoardQueryGraphSettingsArgs',
    'GetQuerySpecificationCalculationArgs',
    'GetQuerySpecificationFilterArgs',
    'GetQuerySpecificationHavingArgs',
    'GetQuerySpecificationOrderArgs',
    'GetRecipientDetailFilterArgs',
    'GetRecipientsDetailFilterArgs',
]

@pulumi.input_type
class BoardQueryArgs:
    def __init__(__self__, *,
                 query_id: pulumi.Input[str],
                 caption: Optional[pulumi.Input[str]] = None,
                 dataset: Optional[pulumi.Input[str]] = None,
                 graph_settings: Optional[pulumi.Input['BoardQueryGraphSettingsArgs']] = None,
                 query_annotation_id: Optional[pulumi.Input[str]] = None,
                 query_style: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query_id: The ID of the Query to run.
        :param pulumi.Input[str] caption: Descriptive text to contextualize the Query within the Board. Supports Markdown.
        :param pulumi.Input[str] dataset: The dataset this query is associated with.
        :param pulumi.Input['BoardQueryGraphSettingsArgs'] graph_settings: A map of boolean toggles to manages the settings for this query's graph on the board.
               If a value is unspecified, it is assumed to be false.
               Currently supported toggles are:
        :param pulumi.Input[str] query_annotation_id: The ID of the Query Annotation to associate with this query.
        :param pulumi.Input[str] query_style: How the query should be displayed within the board, either `graph` (the default), `table` or `combo`.
        """
        pulumi.set(__self__, "query_id", query_id)
        if caption is not None:
            pulumi.set(__self__, "caption", caption)
        if dataset is not None:
            warnings.warn("""Board Queries no longer require the dataset as they rely on the provided Query ID's dataset.""", DeprecationWarning)
            pulumi.log.warn("""dataset is deprecated: Board Queries no longer require the dataset as they rely on the provided Query ID's dataset.""")
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if graph_settings is not None:
            pulumi.set(__self__, "graph_settings", graph_settings)
        if query_annotation_id is not None:
            pulumi.set(__self__, "query_annotation_id", query_annotation_id)
        if query_style is not None:
            pulumi.set(__self__, "query_style", query_style)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> pulumi.Input[str]:
        """
        The ID of the Query to run.
        """
        return pulumi.get(self, "query_id")

    @query_id.setter
    def query_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_id", value)

    @property
    @pulumi.getter
    def caption(self) -> Optional[pulumi.Input[str]]:
        """
        Descriptive text to contextualize the Query within the Board. Supports Markdown.
        """
        return pulumi.get(self, "caption")

    @caption.setter
    def caption(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "caption", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Board Queries no longer require the dataset as they rely on the provided Query ID's dataset.""")
    def dataset(self) -> Optional[pulumi.Input[str]]:
        """
        The dataset this query is associated with.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter(name="graphSettings")
    def graph_settings(self) -> Optional[pulumi.Input['BoardQueryGraphSettingsArgs']]:
        """
        A map of boolean toggles to manages the settings for this query's graph on the board.
        If a value is unspecified, it is assumed to be false.
        Currently supported toggles are:
        """
        return pulumi.get(self, "graph_settings")

    @graph_settings.setter
    def graph_settings(self, value: Optional[pulumi.Input['BoardQueryGraphSettingsArgs']]):
        pulumi.set(self, "graph_settings", value)

    @property
    @pulumi.getter(name="queryAnnotationId")
    def query_annotation_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the Query Annotation to associate with this query.
        """
        return pulumi.get(self, "query_annotation_id")

    @query_annotation_id.setter
    def query_annotation_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_annotation_id", value)

    @property
    @pulumi.getter(name="queryStyle")
    def query_style(self) -> Optional[pulumi.Input[str]]:
        """
        How the query should be displayed within the board, either `graph` (the default), `table` or `combo`.
        """
        return pulumi.get(self, "query_style")

    @query_style.setter
    def query_style(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "query_style", value)


@pulumi.input_type
class BoardQueryGraphSettingsArgs:
    def __init__(__self__, *,
                 hide_markers: Optional[pulumi.Input[bool]] = None,
                 log_scale: Optional[pulumi.Input[bool]] = None,
                 omit_missing_values: Optional[pulumi.Input[bool]] = None,
                 overlaid_charts: Optional[pulumi.Input[bool]] = None,
                 stacked_graphs: Optional[pulumi.Input[bool]] = None,
                 utc_xaxis: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] hide_markers: Disable the overlay of Markers on the graph.
        :param pulumi.Input[bool] log_scale: Set the graph's Y axis to Log scale.
        :param pulumi.Input[bool] omit_missing_values: Enable interpolatation between datapoints when the intervening time buckets have no matching events.
        :param pulumi.Input[bool] overlaid_charts: See [Graph Settings](https://docs.honeycomb.io/working-with-your-data/graph-settings/) in the documentation for more information on any individual setting.
        :param pulumi.Input[bool] stacked_graphs: Enable the display of groups as stacked colored area under their line graphs.
        :param pulumi.Input[bool] utc_xaxis: Set the graph's X axis to UTC.
        """
        if hide_markers is not None:
            pulumi.set(__self__, "hide_markers", hide_markers)
        if log_scale is not None:
            pulumi.set(__self__, "log_scale", log_scale)
        if omit_missing_values is not None:
            pulumi.set(__self__, "omit_missing_values", omit_missing_values)
        if overlaid_charts is not None:
            pulumi.set(__self__, "overlaid_charts", overlaid_charts)
        if stacked_graphs is not None:
            pulumi.set(__self__, "stacked_graphs", stacked_graphs)
        if utc_xaxis is not None:
            pulumi.set(__self__, "utc_xaxis", utc_xaxis)

    @property
    @pulumi.getter(name="hideMarkers")
    def hide_markers(self) -> Optional[pulumi.Input[bool]]:
        """
        Disable the overlay of Markers on the graph.
        """
        return pulumi.get(self, "hide_markers")

    @hide_markers.setter
    def hide_markers(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_markers", value)

    @property
    @pulumi.getter(name="logScale")
    def log_scale(self) -> Optional[pulumi.Input[bool]]:
        """
        Set the graph's Y axis to Log scale.
        """
        return pulumi.get(self, "log_scale")

    @log_scale.setter
    def log_scale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "log_scale", value)

    @property
    @pulumi.getter(name="omitMissingValues")
    def omit_missing_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable interpolatation between datapoints when the intervening time buckets have no matching events.
        """
        return pulumi.get(self, "omit_missing_values")

    @omit_missing_values.setter
    def omit_missing_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "omit_missing_values", value)

    @property
    @pulumi.getter(name="overlaidCharts")
    def overlaid_charts(self) -> Optional[pulumi.Input[bool]]:
        """
        See [Graph Settings](https://docs.honeycomb.io/working-with-your-data/graph-settings/) in the documentation for more information on any individual setting.
        """
        return pulumi.get(self, "overlaid_charts")

    @overlaid_charts.setter
    def overlaid_charts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "overlaid_charts", value)

    @property
    @pulumi.getter(name="stackedGraphs")
    def stacked_graphs(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable the display of groups as stacked colored area under their line graphs.
        """
        return pulumi.get(self, "stacked_graphs")

    @stacked_graphs.setter
    def stacked_graphs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "stacked_graphs", value)

    @property
    @pulumi.getter(name="utcXaxis")
    def utc_xaxis(self) -> Optional[pulumi.Input[bool]]:
        """
        Set the graph's X axis to UTC.
        """
        return pulumi.get(self, "utc_xaxis")

    @utc_xaxis.setter
    def utc_xaxis(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "utc_xaxis", value)


@pulumi.input_type
class GetQuerySpecificationCalculationArgs:
    def __init__(__self__, *,
                 op: str,
                 column: Optional[str] = None):
        """
        :param str op: The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str column: The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "op", op)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[str]):
        pulumi.set(self, "column", value)


@pulumi.input_type
class GetQuerySpecificationFilterArgs:
    def __init__(__self__, *,
                 column: str,
                 op: str,
                 value: Optional[str] = None,
                 value_boolean: Optional[bool] = None,
                 value_float: Optional[float] = None,
                 value_integer: Optional[int] = None,
                 value_string: Optional[str] = None):
        """
        :param str column: The column to apply the filter to.
        :param str op: The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        :param str value: The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.
        :param bool value_boolean: Deprecated: use 'value' instead. The value used for the filter when the column is a boolean. Mutually exclusive with `value` and the other `value_*` options.
               
               * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        :param float value_float: Deprecated: use 'value' instead. The value used for the filter when the column is a float. Mutually exclusive with `value` and the other `value_*` options.
        :param int value_integer: Deprecated: use 'value' instead. The value used for the filter when the column is an integer. Mutually exclusive with `value` and the other `value_*` options.
        :param str value_string: Deprecated: use 'value' instead. The value used for the filter when the column is a string. Mutually exclusive with `value` and the other `value_*` options.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_boolean is not None:
            warnings.warn("""Use of attribute `value_boolean` is discouraged and will fail to plan if using 'false'. Use of `value` is encouraged.""", DeprecationWarning)
            pulumi.log.warn("""value_boolean is deprecated: Use of attribute `value_boolean` is discouraged and will fail to plan if using 'false'. Use of `value` is encouraged.""")
        if value_boolean is not None:
            pulumi.set(__self__, "value_boolean", value_boolean)
        if value_float is not None:
            warnings.warn("""Use of attribute `value_float` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""", DeprecationWarning)
            pulumi.log.warn("""value_float is deprecated: Use of attribute `value_float` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""")
        if value_float is not None:
            pulumi.set(__self__, "value_float", value_float)
        if value_integer is not None:
            warnings.warn("""Use of attribute `value_integer` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""", DeprecationWarning)
            pulumi.log.warn("""value_integer is deprecated: Use of attribute `value_integer` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""")
        if value_integer is not None:
            pulumi.set(__self__, "value_integer", value_integer)
        if value_string is not None:
            warnings.warn("""Use of attribute `value_string` is discouraged and will fail to plan if using the empty string. Use of `value` is encouraged.""", DeprecationWarning)
            pulumi.log.warn("""value_string is deprecated: Use of attribute `value_string` is discouraged and will fail to plan if using the empty string. Use of `value` is encouraged.""")
        if value_string is not None:
            pulumi.set(__self__, "value_string", value_string)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The column to apply the filter to.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: str):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueBoolean")
    @_utilities.deprecated("""Use of attribute `value_boolean` is discouraged and will fail to plan if using 'false'. Use of `value` is encouraged.""")
    def value_boolean(self) -> Optional[bool]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is a boolean. Mutually exclusive with `value` and the other `value_*` options.

        * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        """
        return pulumi.get(self, "value_boolean")

    @value_boolean.setter
    def value_boolean(self, value: Optional[bool]):
        pulumi.set(self, "value_boolean", value)

    @property
    @pulumi.getter(name="valueFloat")
    @_utilities.deprecated("""Use of attribute `value_float` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""")
    def value_float(self) -> Optional[float]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is a float. Mutually exclusive with `value` and the other `value_*` options.
        """
        return pulumi.get(self, "value_float")

    @value_float.setter
    def value_float(self, value: Optional[float]):
        pulumi.set(self, "value_float", value)

    @property
    @pulumi.getter(name="valueInteger")
    @_utilities.deprecated("""Use of attribute `value_integer` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""")
    def value_integer(self) -> Optional[int]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is an integer. Mutually exclusive with `value` and the other `value_*` options.
        """
        return pulumi.get(self, "value_integer")

    @value_integer.setter
    def value_integer(self, value: Optional[int]):
        pulumi.set(self, "value_integer", value)

    @property
    @pulumi.getter(name="valueString")
    @_utilities.deprecated("""Use of attribute `value_string` is discouraged and will fail to plan if using the empty string. Use of `value` is encouraged.""")
    def value_string(self) -> Optional[str]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is a string. Mutually exclusive with `value` and the other `value_*` options.
        """
        return pulumi.get(self, "value_string")

    @value_string.setter
    def value_string(self, value: Optional[str]):
        pulumi.set(self, "value_string", value)


@pulumi.input_type
class GetQuerySpecificationHavingArgs:
    def __init__(__self__, *,
                 calculate_op: str,
                 op: str,
                 value: float,
                 column: Optional[str] = None):
        """
        :param str calculate_op: The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        :param str op: The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        :param float value: The value used with `op`. Currently assumed to be a number.
               
               > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        :param str column: The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "calculate_op", calculate_op)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter(name="calculateOp")
    def calculate_op(self) -> str:
        """
        The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        """
        return pulumi.get(self, "calculate_op")

    @calculate_op.setter
    def calculate_op(self, value: str):
        pulumi.set(self, "calculate_op", value)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: str):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value used with `op`. Currently assumed to be a number.

        > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: float):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[str]):
        pulumi.set(self, "column", value)


@pulumi.input_type
class GetQuerySpecificationOrderArgs:
    def __init__(__self__, *,
                 column: Optional[str] = None,
                 op: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str column: Either a column present in `breakdown` or a column to `op` applies to.
        :param str op: The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str order: The sort direction, if set must be `ascending` or `descending`.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        Either a column present in `breakdown` or a column to `op` applies to.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[str]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort direction, if set must be `ascending` or `descending`.
        """
        return pulumi.get(self, "order")

    @order.setter
    def order(self, value: Optional[str]):
        pulumi.set(self, "order", value)


@pulumi.input_type
class GetRecipientDetailFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")

    @value_regex.setter
    def value_regex(self, value: Optional[str]):
        pulumi.set(self, "value_regex", value)


@pulumi.input_type
class GetRecipientsDetailFilterArgs:
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: str):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")

    @value_regex.setter
    def value_regex(self, value: Optional[str]):
        pulumi.set(self, "value_regex", value)


