# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'BoardQuery',
    'BoardQueryGraphSettings',
    'GetQuerySpecificationCalculationResult',
    'GetQuerySpecificationFilterResult',
    'GetQuerySpecificationHavingResult',
    'GetQuerySpecificationOrderResult',
    'GetRecipientDetailFilterResult',
    'GetRecipientsDetailFilterResult',
]

@pulumi.output_type
class BoardQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryId":
            suggest = "query_id"
        elif key == "graphSettings":
            suggest = "graph_settings"
        elif key == "queryAnnotationId":
            suggest = "query_annotation_id"
        elif key == "queryStyle":
            suggest = "query_style"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BoardQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BoardQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BoardQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_id: str,
                 caption: Optional[str] = None,
                 dataset: Optional[str] = None,
                 graph_settings: Optional['outputs.BoardQueryGraphSettings'] = None,
                 query_annotation_id: Optional[str] = None,
                 query_style: Optional[str] = None):
        """
        :param str query_id: The ID of the Query to run.
        :param str caption: Descriptive text to contextualize the Query within the Board. Supports Markdown.
        :param str dataset: The dataset this query is associated with.
        :param 'BoardQueryGraphSettingsArgs' graph_settings: A map of boolean toggles to manages the settings for this query's graph on the board.
               If a value is unspecified, it is assumed to be false.
               Currently supported toggles are:
        :param str query_annotation_id: The ID of the Query Annotation to associate with this query.
        :param str query_style: How the query should be displayed within the board, either `graph` (the default), `table` or `combo`.
        """
        pulumi.set(__self__, "query_id", query_id)
        if caption is not None:
            pulumi.set(__self__, "caption", caption)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if graph_settings is not None:
            pulumi.set(__self__, "graph_settings", graph_settings)
        if query_annotation_id is not None:
            pulumi.set(__self__, "query_annotation_id", query_annotation_id)
        if query_style is not None:
            pulumi.set(__self__, "query_style", query_style)

    @property
    @pulumi.getter(name="queryId")
    def query_id(self) -> str:
        """
        The ID of the Query to run.
        """
        return pulumi.get(self, "query_id")

    @property
    @pulumi.getter
    def caption(self) -> Optional[str]:
        """
        Descriptive text to contextualize the Query within the Board. Supports Markdown.
        """
        return pulumi.get(self, "caption")

    @property
    @pulumi.getter
    @_utilities.deprecated("""Board Queries no longer require the dataset as they rely on the provided Query ID's dataset.""")
    def dataset(self) -> Optional[str]:
        """
        The dataset this query is associated with.
        """
        return pulumi.get(self, "dataset")

    @property
    @pulumi.getter(name="graphSettings")
    def graph_settings(self) -> Optional['outputs.BoardQueryGraphSettings']:
        """
        A map of boolean toggles to manages the settings for this query's graph on the board.
        If a value is unspecified, it is assumed to be false.
        Currently supported toggles are:
        """
        return pulumi.get(self, "graph_settings")

    @property
    @pulumi.getter(name="queryAnnotationId")
    def query_annotation_id(self) -> Optional[str]:
        """
        The ID of the Query Annotation to associate with this query.
        """
        return pulumi.get(self, "query_annotation_id")

    @property
    @pulumi.getter(name="queryStyle")
    def query_style(self) -> Optional[str]:
        """
        How the query should be displayed within the board, either `graph` (the default), `table` or `combo`.
        """
        return pulumi.get(self, "query_style")


@pulumi.output_type
class BoardQueryGraphSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hideMarkers":
            suggest = "hide_markers"
        elif key == "logScale":
            suggest = "log_scale"
        elif key == "omitMissingValues":
            suggest = "omit_missing_values"
        elif key == "overlaidCharts":
            suggest = "overlaid_charts"
        elif key == "stackedGraphs":
            suggest = "stacked_graphs"
        elif key == "utcXaxis":
            suggest = "utc_xaxis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BoardQueryGraphSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BoardQueryGraphSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BoardQueryGraphSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hide_markers: Optional[bool] = None,
                 log_scale: Optional[bool] = None,
                 omit_missing_values: Optional[bool] = None,
                 overlaid_charts: Optional[bool] = None,
                 stacked_graphs: Optional[bool] = None,
                 utc_xaxis: Optional[bool] = None):
        """
        :param bool hide_markers: Disable the overlay of Markers on the graph.
        :param bool log_scale: Set the graph's Y axis to Log scale.
        :param bool omit_missing_values: Enable interpolatation between datapoints when the intervening time buckets have no matching events.
        :param bool overlaid_charts: See [Graph Settings](https://docs.honeycomb.io/working-with-your-data/graph-settings/) in the documentation for more information on any individual setting.
        :param bool stacked_graphs: Enable the display of groups as stacked colored area under their line graphs.
        :param bool utc_xaxis: Set the graph's X axis to UTC.
        """
        if hide_markers is not None:
            pulumi.set(__self__, "hide_markers", hide_markers)
        if log_scale is not None:
            pulumi.set(__self__, "log_scale", log_scale)
        if omit_missing_values is not None:
            pulumi.set(__self__, "omit_missing_values", omit_missing_values)
        if overlaid_charts is not None:
            pulumi.set(__self__, "overlaid_charts", overlaid_charts)
        if stacked_graphs is not None:
            pulumi.set(__self__, "stacked_graphs", stacked_graphs)
        if utc_xaxis is not None:
            pulumi.set(__self__, "utc_xaxis", utc_xaxis)

    @property
    @pulumi.getter(name="hideMarkers")
    def hide_markers(self) -> Optional[bool]:
        """
        Disable the overlay of Markers on the graph.
        """
        return pulumi.get(self, "hide_markers")

    @property
    @pulumi.getter(name="logScale")
    def log_scale(self) -> Optional[bool]:
        """
        Set the graph's Y axis to Log scale.
        """
        return pulumi.get(self, "log_scale")

    @property
    @pulumi.getter(name="omitMissingValues")
    def omit_missing_values(self) -> Optional[bool]:
        """
        Enable interpolatation between datapoints when the intervening time buckets have no matching events.
        """
        return pulumi.get(self, "omit_missing_values")

    @property
    @pulumi.getter(name="overlaidCharts")
    def overlaid_charts(self) -> Optional[bool]:
        """
        See [Graph Settings](https://docs.honeycomb.io/working-with-your-data/graph-settings/) in the documentation for more information on any individual setting.
        """
        return pulumi.get(self, "overlaid_charts")

    @property
    @pulumi.getter(name="stackedGraphs")
    def stacked_graphs(self) -> Optional[bool]:
        """
        Enable the display of groups as stacked colored area under their line graphs.
        """
        return pulumi.get(self, "stacked_graphs")

    @property
    @pulumi.getter(name="utcXaxis")
    def utc_xaxis(self) -> Optional[bool]:
        """
        Set the graph's X axis to UTC.
        """
        return pulumi.get(self, "utc_xaxis")


@pulumi.output_type
class GetQuerySpecificationCalculationResult(dict):
    def __init__(__self__, *,
                 op: str,
                 column: Optional[str] = None):
        """
        :param str op: The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str column: The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "op", op)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the operator to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")


@pulumi.output_type
class GetQuerySpecificationFilterResult(dict):
    def __init__(__self__, *,
                 column: str,
                 op: str,
                 value: Optional[str] = None,
                 value_boolean: Optional[bool] = None,
                 value_float: Optional[float] = None,
                 value_integer: Optional[int] = None,
                 value_string: Optional[str] = None):
        """
        :param str column: The column to apply the filter to.
        :param str op: The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        :param str value: The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.
        :param bool value_boolean: Deprecated: use 'value' instead. The value used for the filter when the column is a boolean. Mutually exclusive with `value` and the other `value_*` options.
               
               * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        :param float value_float: Deprecated: use 'value' instead. The value used for the filter when the column is a float. Mutually exclusive with `value` and the other `value_*` options.
        :param int value_integer: Deprecated: use 'value' instead. The value used for the filter when the column is an integer. Mutually exclusive with `value` and the other `value_*` options.
        :param str value_string: Deprecated: use 'value' instead. The value used for the filter when the column is a string. Mutually exclusive with `value` and the other `value_*` options.
        """
        pulumi.set(__self__, "column", column)
        pulumi.set(__self__, "op", op)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_boolean is not None:
            pulumi.set(__self__, "value_boolean", value_boolean)
        if value_float is not None:
            pulumi.set(__self__, "value_float", value_float)
        if value_integer is not None:
            pulumi.set(__self__, "value_integer", value_integer)
        if value_string is not None:
            pulumi.set(__self__, "value_string", value_string)

    @property
    @pulumi.getter
    def column(self) -> str:
        """
        The column to apply the filter to.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply, see the supported list of filter operators at [Filter Operators](https://docs.honeycomb.io/api/query-specification/#filter-operators). Not all operators require a value.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value used for the filter. Not needed if op is `exists` or `not-exists`. Mutually exclusive with the other `value_*` options.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueBoolean")
    @_utilities.deprecated("""Use of attribute `value_boolean` is discouraged and will fail to plan if using 'false'. Use of `value` is encouraged.""")
    def value_boolean(self) -> Optional[bool]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is a boolean. Mutually exclusive with `value` and the other `value_*` options.

        * > **NOTE** Filter op `in` and `not-in` expect an array of strings as value. Use the `value` attribute and pass the values in single string separated by `,` without additional spaces (similar to the query builder in the UI). For example: the list `foo`, `bar` becomes `foo,bar`.
        """
        return pulumi.get(self, "value_boolean")

    @property
    @pulumi.getter(name="valueFloat")
    @_utilities.deprecated("""Use of attribute `value_float` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""")
    def value_float(self) -> Optional[float]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is a float. Mutually exclusive with `value` and the other `value_*` options.
        """
        return pulumi.get(self, "value_float")

    @property
    @pulumi.getter(name="valueInteger")
    @_utilities.deprecated("""Use of attribute `value_integer` is discouraged and will fail to plan if using '0'. Use of `value` is encouraged.""")
    def value_integer(self) -> Optional[int]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is an integer. Mutually exclusive with `value` and the other `value_*` options.
        """
        return pulumi.get(self, "value_integer")

    @property
    @pulumi.getter(name="valueString")
    @_utilities.deprecated("""Use of attribute `value_string` is discouraged and will fail to plan if using the empty string. Use of `value` is encouraged.""")
    def value_string(self) -> Optional[str]:
        """
        Deprecated: use 'value' instead. The value used for the filter when the column is a string. Mutually exclusive with `value` and the other `value_*` options.
        """
        return pulumi.get(self, "value_string")


@pulumi.output_type
class GetQuerySpecificationHavingResult(dict):
    def __init__(__self__, *,
                 calculate_op: str,
                 op: str,
                 value: float,
                 column: Optional[str] = None):
        """
        :param str calculate_op: The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        :param str op: The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        :param float value: The value used with `op`. Currently assumed to be a number.
               
               > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        :param str column: The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        pulumi.set(__self__, "calculate_op", calculate_op)
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "value", value)
        if column is not None:
            pulumi.set(__self__, "column", column)

    @property
    @pulumi.getter(name="calculateOp")
    def calculate_op(self) -> str:
        """
        The calculation operator to apply, supports all of the [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators) with the exception of `HEATMAP`.
        """
        return pulumi.get(self, "calculate_op")

    @property
    @pulumi.getter
    def op(self) -> str:
        """
        The operator to apply to filter the query results. One of `=`, `!=`, `>`, `>=`, `<`, or `<=`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def value(self) -> float:
        """
        The value used with `op`. Currently assumed to be a number.

        > **NOTE** A having term's `column`/`calculate_op` pair must have a corresponding `calculation`. There can be multiple `having` blocks for the same `column`/`calculate_op` pair.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        The column to apply the `calculate_op` to, not needed with `COUNT` or `CONCURRENCY`.
        """
        return pulumi.get(self, "column")


@pulumi.output_type
class GetQuerySpecificationOrderResult(dict):
    def __init__(__self__, *,
                 column: Optional[str] = None,
                 op: Optional[str] = None,
                 order: Optional[str] = None):
        """
        :param str column: Either a column present in `breakdown` or a column to `op` applies to.
        :param str op: The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        :param str order: The sort direction, if set must be `ascending` or `descending`.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if order is not None:
            pulumi.set(__self__, "order", order)

    @property
    @pulumi.getter
    def column(self) -> Optional[str]:
        """
        Either a column present in `breakdown` or a column to `op` applies to.
        """
        return pulumi.get(self, "column")

    @property
    @pulumi.getter
    def op(self) -> Optional[str]:
        """
        The calculation operator to apply, see the supported list of calculation operators at [Calculation Operators](https://docs.honeycomb.io/api/query-specification/#calculation-operators).
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def order(self) -> Optional[str]:
        """
        The sort direction, if set must be `ascending` or `descending`.
        """
        return pulumi.get(self, "order")


@pulumi.output_type
class GetRecipientDetailFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")


@pulumi.output_type
class GetRecipientsDetailFilterResult(dict):
    def __init__(__self__, *,
                 name: str,
                 value: Optional[str] = None,
                 value_regex: Optional[str] = None):
        """
        :param str name: The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        :param str value: The value of the detail field to match on.
        :param str value_regex: A regular expression string to apply to the value of the detail field to match on.
               
               > **Note** one of `value` or `value_regex` is required.
        """
        pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_regex is not None:
            pulumi.set(__self__, "value_regex", value_regex)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the detail field to filter by. Allowed values are `address`, `channel`, `name`, `integration_name`, and `url`.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        The value of the detail field to match on.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueRegex")
    def value_regex(self) -> Optional[str]:
        """
        A regular expression string to apply to the value of the detail field to match on.

        > **Note** one of `value` or `value_regex` is required.
        """
        return pulumi.get(self, "value_regex")


